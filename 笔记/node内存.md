它与Java一样，由垃圾回收机制来进行自动内存管理

对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响

node在发展历程中离不开v8，Node是一个构建在Chrome的JavaScript运行时上的平台

### V8的内存限制

在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存

造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的

v8的内存限制本来是为浏览器设计的，但在node中却对大内存做了限制

### V8的对象分配

js中的对象是通过堆分配的

```
$ node
> process.memoryUsage(); 
{ rss: 14958592,
  heapTotal: 7195904,// v8堆内存使用状况
  heapUsed: 2821496 // v8堆内存使用状况
}
```

当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲 内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止

v8限制内存的原因
- 本来为网页设计
- 在大内存回收时v8的时间较长

### v8垃圾回收机制

- v8内存分代

在V8中，主要将内存分为**新生代**和**老生代**两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象

V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间

这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错

- Scavenge算法

在分代基础上，新生代通过Scavenge算法进行垃圾回收

- Mark-Sweep（标记清除） & Mark-Compact（标记整理）

在老生代中使用，老生代中存活对象占较大比重，不适合用Scavenge算法

- Incremental Marking(增量标记)