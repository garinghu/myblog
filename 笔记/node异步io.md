为什么要异步
1. 用户体验
js在浏览器中单线程执行
前端通过异步消除ui阻塞
后端也需要快速响应
2. 资源分配
多线程开销大，会面临死锁等问题，但会增加cpu利用率
单线程顺序执行会产生阻塞
node: 单线程异步i/o，通过子进程高效利用cpu

异步和非阻塞i/o达到了并行i/o的目的

阻塞i/o:在调用阻塞I/O时，应用程序需要等待 I/O完成才返回结果
非阻塞i/o:i/o请求后立即返回，通过轮询查看是否完成，会对cpu造成浪费
理想的异步i/o: 应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等 方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序即可

现实的异步i/o
通过让部分线程进行阻塞I/O或者非阻塞I/O加 轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递(线程池)

Node的异步i/o
- 事件循环

在进程启动时，执行while循环，每个过程成为tick
- 观察者

在每次tick时如何判断是否有事件进行，对于不同的请求类型放入对应的观察者，事件循环则从观察者那里取出事件并处理
- 请求对象

在js层发起请求后，会经历一系列调用到线程池等待执行，其中的所有信息会封装成请求对象，此时异步i/o的调用阶段结束，js主线程会继续下一步操作（线程池是在底层实现的）


- setTimeout

放在一个timer_handler中等待，每轮tick时检查handler中是否有到等待时间的，用红黑树构建，创建比较耗性能O(lg(n))

- process.nextTick()

直接放入事件队列中，在下一次tick时取出执行O(1)，属于idle观察者
保存在数组中，每次tick时会全部取出并执行
```javascript
process.nextTick(function () {
  console.log('延迟执行');
});
```

- setImmediate()

属于check观察者
process.nextTick()中的回调函数执行的优先级要高于setImmediate()
保存在链表中，每次只取出并执行第一个

- 网络请求

在套接字上侦听请求，并发送给对应的观察者，js通过绑定事件执行回调，事件驱动(主循环加事件触发)

