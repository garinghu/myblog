将值从一种类型转换为另一种类型通常称为类型转换(type casting)，这是显式的情况;隐
式的情况称为强制类型转换(coercion)

JavaScript 中的强制类型转换总是返回标量基本类型值(参见第 2 章)，如字 符串、数字和布尔值，不会返回对象和函数。

var a = 42;
var b = a + ""; // 隐式强制类型转换 
var c = String( a ); // 显式强制类型转换

[]的toString被重写过，返回""，而""会被转为0，所以[ ]会被转为0

String: toString
Number: valueOf -> toString -> 强制类型转换

parseInt: 只接受string，否则会先转成string

+默认是按Number转，只要有一方是""，则按String转，其他的(-/*)会按数值转

== 最终都会转换成数值


[] + {}


### 什么是强制类型转换
我们把“把值从一种类型转变成另一种类型”称为类型转换，其中隐式的情况称为强制类型转换。

强制类型转换可以理解为一套规则的实现，通过实现这种规则可以尽量避免JS抛出错误，在一定程度上也会更加灵活。当然弊端也很明显，这套规则很难成为体系，不易记忆，使很多开发者退避三舍。


### 为什么要强制类型转换
（可能）实现了强制类型转换会尽量使JS减少报错，使JS尽可能解释每一个表达式，举个栗子：
```
var a = 1;
var b = '12'
var c = a + b;
c   // '112'
```
a的类型是Number类型，而b是String类型，两者自然是无法相加的，但JS为了解释这个表达式，需要将a和b转换为相同的类型，在当前的语境下，'+'运算符的规则是**将“+”前后的值转换为Number类型，但如果其中一方是String类型，则都转换为String类型**，按照这条规则，a需要转换为String类型，级为'1'，所以结果为'112'。

再看下面的栗子：
```
var a = 1;
var b = '12'
var c = a - b;
c   // -11
```
为什么结果不是字符串而是按照数字计算规则计算出了结果？是因为'-'的规则与'+'不同，虽然可能是相同的值，但在不同的语境下的规则也不同，当我们知道了大部分情况下的规则，我们便真正理解了强制类型转换

### 抽象值操作
上面的栗子，'+'需要将前后的值转换为Number类型，但如何去将所有类型（包括引用类型）转换为Number类型呢？这是我们需要了解的另一套规则。

常用的转换为以下几种
- toNumber
- toString
- toBoolean

因为这几种并非是JS内置的API，而是一种抽象的逻辑，所以也被称为抽象值操作

#### toString
用来处理非字符串到字符串的强制类型转换。

显示的转换为

```
var a = 1;
a.toString(); // '1'
```
1. 基本类型
- null -> 'null'
- undefined -> 'undefined'
- true/false -> 'true'/'false'
- Number: 极大数字会转换为指数形式再转成字符串，无限则会转换为'Infinity'

2. 引用类型
对普通对象来说，除非自行定义，否则 toString()(Object.prototype.toString())返回 内部属性 [[Class]] 的值，如 "[object Object]"。

但引用类型的转换并非是仅仅通过toString方法，需要通过另一个抽象值操作--toPrimitive，这个放在后面去讲。

但数组的toString方法经过了重新定义，其结果为：
```
var a = [1,2,3];
a.toString();   // "1,2,3"
```
转变为将不同成员以","分隔的字符串。

如果我们自己定义toString方法呢？

```
var a = {
    a: 1,
    toString: function() {
        return '123'
    }
};  // 重新定义了toString方法
var b = a + '12';
b   // '12312'
```

#### toNumber
1. 基本类型
- true -> 1
- false -> 0
- undefined -> NaN
- null -> 0
- 字符串：ToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法。处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)。**这里需要注意的是：空字符串是转换为0的**

2. 引用类型
这里需要介绍下toPrimitive，大致可以分为以下步骤：
- 检查该值是否有 valueOf() 方法。 如果有并且返回基本类型值，就使用该值进行强制类型转换
- 如果没有就使用 toString()
的返回值(如果存在)来进行强制类型转换
- 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误

为了熟悉上面的过程，先来看个栗子：
```
var a = {};
a + 12 //"[object Object]12"
```
结果可以这样解释：
- a为引用类型，需要用toPrimitive先转成基本类型
- 调用a的valueOf方法，返回{}，不是基本类型
- 调用a的toString方法，返回"[object Object]"，是基本类型，表达式相当于"[object Object]" + 12
- '+'的规则为一方是字符串则另一方也要转为字符串，所以结果为"[object Object]12"

在toNumber中，如果转换为"[object Object]"再转换为Number类型的话则会转为NaN。

如果是数组的话，toString方法会转为空字符串，而空字符串转换为0，这个需要注意。

#### toBoolean
在JS中，布尔类型分为真值（true）和假值（false）
1. 假值
- undefined
- null
- false
- +0,-0,NaN
- ""
2. 真值
真值就是假值列表之外的值。除了上面的值，其他值都为真值，在toBoolean中都会转换为true的

需要注意的是，引用类型在toBoolean中是不需要toPrimitive的，空数组不会转为空字符串，所以空数组也是真值。

### 强制类型转换
知道了各种类型的转换思路，下面就应该去了解在不同的语境下该以什么规则去转换了

#### 字符串和数字的转换
常见的为"+, -, *, /"运算
```
var a = '12';
var b = 12;
a + b   // '1212'
a - b   // 0
a * b   // 144
a / b   // 1
```
上面说过，'+'的一方为字符串，则按照字符串转换

但‘-, *, /’主要用于数值运算，所以要都转换为Number

#### 隐式类型转换为布尔值
在下面的情况下会强制转换为布尔值
1. if (..) 语句中的条件判断表达式。
2. for ( .. ; .. ; .. ) 语句中的条件判断表达式(第二个)。
3. while (..) 和 do..while(..) 循环中的条件判断表达式。
4. ? : 中的条件判断表达式。
5. 逻辑运算符 ||(逻辑或)和 &&(逻辑与)左边的操作数(作为条件判断表达式)。

#### 宽松相等（==）
ES5 规范 11.9.3 节的“抽象相等比较算法”定义了 == 运算符的行为。该算法简单而又全
面，涵盖了所有可能出现的类型组合，以及它们进行强制类型转换的方式。

其中第一段(11.9.3.1)规定如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，"abc" 等于 "abc"。

但需要注意以下亮点
- NaN不等于NaN
- +0等于-0

如果类型不同呢？

1. 字符串和数字之间的相等比较：会将字符串转换为数字
2. 其他类型与布尔值的比较
```
var a = "1";
var b = true;
a == b  //false
```
a是真值，但与b的抽象相等比较为false，其规则为**布尔值会转换为Number类型再去比较**

现在分析以下上面的代码
- b为布尔值，转换为Number类型为0，表达式变为 "1" == 0
- 根据字符串和数字之间的相等比较，将字符串转为数字，表达式变为 1 == 0
- 结果为false

通过上面两条基本可以推算出任何类型的值与布尔值比较的转换规则，再看一个栗子：
```
var a = [];
var b = false;
a == b  //true
```
- b为布尔值，转换为Number类型为0，表达式变为 [] == 0
- []会先进行toPrimitive，转为空字符串，表达式变为 "" == 0
- 字符串需要转为Number类型，0 == 0，结果为true


所以在判断中不要写 **==false**

3. null 和 undefined 之间的相等比较
null 和 undefined 之间的 == 也涉及隐式强制类型转换，规则如下：
```
null == undefined // true
```
在抽象相等中，null和undefined是等价的

4. 对象与非对象间的相等比较
如果其中一个为Number或String，会将对象转换进行toPrimitive再去比较

如果其中一方是布尔型，会将布尔型转换为Number

看个栗子：
```
var a = 12;
var b = [12];
a == b  // true
```
- b为引用类型，进行toPrimitive，变为 12 == '12'
- 将字符串转为数字，变为 12 == 12 返回true

5. 几个特殊情况（根据规则无法解释）



